[{"content":" Preface This is a starters\u0026#39; guide for somebody wanting to try out emacs, coming from nvim. This is written from my perspective as somebody who used Neovim for a while. I had a configuration I was really happy with when using nvim, but its\u0026#39; limitations made my eyes wander to other options.\nSince then, I\u0026#39;ve switched and landed on emacs as my preferred editor, and I\u0026#39;m extremely happy with it. I had many preconceived notions against emacs prior to actually giving it an honest shot.\n\u0026#34;Emacs is slow!\u0026#34; \u0026#34;Emacs is bloated!\u0026#34; \u0026#34;Emacs is outdated!\u0026#34; \u0026#34;Emacs is \u0026lt;insert notion here\u0026gt;!\u0026#34; But after giving it an honest shot, those notions either don\u0026#39;t make a real world difference, or aren\u0026#39;t true at all.\nMy main reasons for switching to emacs compared to neovim:\nConfiguration and Extensiblity Emacs is entirely configured in a single language, elisp, and emacs itself is primarily written using this language. With this being the case, when you configure emacs, you\u0026#39;re basically editing the source code itself, instead of interacting with a predefined API such as neovim. Emacs lets you configure the core functionality of emacs itself, and do many things which just aren\u0026#39;t possible in neovim.\nThis allows for a far greater degree of customizability, which is important because I feel an editor you spend a large amount of time in should be custom suited to your needs or prefernces, no matter how granular. Documentation Emacs is self-documenting. You can view definitions of functions and variables directly from within emacs to see what they\u0026#39;re meant to do and why they are there. Anytime you see a function in someone\u0026#39;s configuration, and you wonder: \u0026#34;What is this even doing\u0026#34;, you can use build in functions like describe-variable or describe-function to view them.\nFor example, if I use the describe-variable function to view the definition of the gc-cons-threshold I would get the following display:\nPackages Emacs has packages/plugins written for it that I cannot find a suitable replacement for in neovim. Whether that be due to the fact that they simply haven\u0026#39;t been written yet, or phycially can\u0026#39;t exist within neovim due to previously mentioned API limitations, or the lack of a GUI.\nA few examples of these packages/features in my case include:\nMagit An unbeatable git client Org Mode A mode for writing notes and documents in markup (this webpage is written in org) Tramp The built-in remote connection client, allows connecting and editing files over SSH, SMB, etc, without having to install another instance of the editor on a remote device. Dired The built-in file browser. Dired is one of the best file browsers I\u0026#39;ve used in general, not just in regards to editors. Getting Started With the preface in mind, this will be a short guide to start building your emacs configuration, including some packages which I feel are essential to the experience for anyone coming from neovim. This is not meant to be the full experience, and I may delve into deeper configuration with things like LSP and Treesitter in a later article. This guilde is meant to serve as a starter point.\nAs previously mentioned, emacs is written and configured using elisp. For a run-down on how the language works, check out my other guide here. Emacs searches for an init.el file in the ~/.emacs.d first, then ~/.config/emacs OR $XDG_CONFIG_HOME/emacs if it is set.\nHere are some useful keybinds for when getting started (C = Ctrl, M = Meta/Alt):\nM-x - The command launcher, you can use this to execute any interactive function in emacs, like describe-variable or describe-function C-h v - Built in shortcut for using the describe-variable function to view a variable\u0026#39;s definition C-h f - Built in shortcut for using the describe-function function to view a function\u0026#39;s definition Package Manager To start things out, we\u0026#39;ll need to enable and use the build in package-manager, package.el. We can add the following lines to our configuration to start using it:\n(require \u0026#39;package) ; load the package manager (setq package-check-signature nil) ; override signature errors ;; add package archives to package manager (add-to-list \u0026#39;package-archives \u0026#39;(\u0026#34;melpa\u0026#34; . \u0026#34;https://melpa.org/packages/\u0026#34;) t) (package-initialize) ; exactly what it sounds like ;; pull archvies and prevent warning messages only on very first startup (unless package-archive-contents (progn (setq warning-minimum-level :emergency) (package-refresh-contents))) This will load the package manager, and pull the package archives and MELPA and the default ELPA on the first startup.\nNext, we can setup use-package which is a unified framework that simplifies and consilidates the installation and configuration of packages. To do so, drop the following into your configuration:\n;; install use-package if it doesn\u0026#39;t exist yet (unless (package-installed-p \u0026#39;use-package) (package-install \u0026#39;use-package)) (require \u0026#39;use-package) ; load use-package ;; Make use-package uses package.el, prevents having to use :ensure t on everything (setq use-package-always-ensure t) The above elisp will install use-package if it doesn\u0026#39;t exist, and integrate it with the package manager.\nYou\u0026#39;ll see many keywords with use-package during this guide. To see them all, you can use the keybind C-h f on use-package to see them all, but here are the ones used in this guide:\ninit - This section is run before the package is loaded config - This section is run after the package is loaded after - Load the package only after a differnt specified package is loaded general - Used for general integration for keybinds, which I will cover a bit further down, this is only an option if you have general.el installed Evil Mode Definitely the most important package for someone migrating from neovim/vim. This packages enables emacs to ues Vim bindings in almost the exact same fashion you may be used to. For me, vim bindings are essential.\nTo install and use evil, you can use the following:\n(use-package evil :init (setq evil-want-keybinding nil) ; needed when using with evil collection :config (evil-mode 1)) (use-package evil-collection :after evil :config (setq evil-collection-mode-list \u0026#39;(magit term help dashboard dired ibuffer tetris)) (evil-collection-init)) This will install and configure evil-mode and evil-collection. Evil-collection is a set of predefined vim bindings for many popular build in modes, and other popular packages. You can see the defined modes we added to this example are magit, term, help, dashboard, dired, and ibuffer. (also tetris)\nKeybinds General Now that we have evil mode setup, we can start defining our own personal binds. Working with bindings with Evil-Mode can be tricky and there can be some gotcha\u0026#39;s, so, I recommend using a package called general to simply this.\nSimilar to use-package, general is a unified framework to operate on keybindings, and has special integration with evil.\nTo start using it, we can add the following:\n(use-package general :config ;; By default, to escape the mini-buffer, you need to hit ESC 3 times, this ;; bind changes that, so it only takes one. (general-define-key :keymaps \u0026#39;minibuffer-local-map \u0026#34;\u0026lt;escape\u0026gt;\u0026#34; #\u0026#39;keyboard-escape-quit) ;; Let an active leader key for normal, visual, and emacs states (general-create-definer leader :states \u0026#39;(normal visual emacs) :keymaps \u0026#39;override :prefix \u0026#34;SPC\u0026#34; ;; set leader :global-prefix \u0026#34;M-SPC\u0026#34;) ;; access leader in insert mode (leader \u0026#34;f\u0026#34; \u0026#39;(:ignore t :wk \u0026#34;Find file\u0026#34;) \u0026#34;f f\u0026#34; \u0026#39;(find-file :wk \u0026#34;Find file directly\u0026#34;)) (leader \u0026#34;b\u0026#34; \u0026#39;(:ignore t :wk \u0026#34;Buffer\u0026#34;) \u0026#34;b f\u0026#34; \u0026#39;(switch-to-buffer* :wk \u0026#34;Find a buffer, or create a new one\u0026#34;) \u0026#34;b k\u0026#34; \u0026#39;(kill-this-buffer :wk \u0026#34;Kill the current buffer\u0026#34;) \u0026#34;b r\u0026#34; \u0026#39;(revert-buffer :wk \u0026#34;Reload the current buffer\u0026#34;)) (leader \u0026#34;c\u0026#34; \u0026#39;(:ignore t :wk \u0026#34;Comment\u0026#34;) \u0026#34;c r\u0026#34; \u0026#39;(comment-region :wk \u0026#34;Comment selection\u0026#34;) \u0026#34;c l\u0026#34; \u0026#39;(comment-line :wk \u0026#34;Comment line\u0026#34;)) (leader \u0026#34;h\u0026#34; \u0026#39;(:ignore t :wk \u0026#34;Help\u0026#34;) \u0026#34;h f\u0026#34; \u0026#39;(describe-function :wk \u0026#34;Help function\u0026#34;) \u0026#34;h v\u0026#34; \u0026#39;(describe-variable :wk \u0026#34;Help variable\u0026#34;) \u0026#34;h m\u0026#34; \u0026#39;(describe-mode :wk \u0026#34;Help mode\u0026#34;) \u0026#34;h c\u0026#34; \u0026#39;(describe-char :wk \u0026#34;Help character\u0026#34;) \u0026#34;h k\u0026#34; \u0026#39;(describe-key :wk \u0026#34;Help key/keybind\u0026#34;))) In this example, we define a key-override for the minibuffer-local-map. This keymap is used when interacting with the minibuffer, such as when using M-x.\nFollowing that, we setup a leader key, which I use space for. The :ignore keyword will ignore the keypress so no action is triggered until a followup key defined it pressed. The :wk keyword adds a description used for which-key integration, which we will setup shortly.\nKeychord If you\u0026#39;re like me, I always prefered to have ESCAPE mapped to jj in vim. You can recreate this behavior in Emacs with the keychord package.\nHeres an examle:\n(use-package key-chord :init (key-chord-mode 1) :config (setq key-chord-two-keys-delay 1 key-chord-one-key-delay 1.2 key-chord-safety-interval-forward 0.1 key-chord-safety-interval-backward 1) (key-chord-define evil-insert-state-map \u0026#34;jj\u0026#34; \u0026#39;evil-normal-state)) The settings defined in the config are what I feel to be the closest to the default neovim/vim settings. Here, we map jj to return to the evil-normal-state.\nWhich Key If you\u0026#39;ve used neovim/vim, you\u0026#39;ve probably setup which-key there at some point as well. Which-key shows a menu displaying possible followup keybinds corresponding to the given key you pressed.\nHere\u0026#39;s how we can set it up:\n(use-package which-key :init (which-key-mode 1) :config (setq which-key-side-window-location \u0026#39;bottom which-key-sort-order #\u0026#39;which-key-key-order-alpha which-key-sort-uppercase-first nil which-key-add-column-padding 1 which-key-max-display-columns nil which-key-min-display-lines 6 which-key-side-window-slot -10 which-key-side-window-max-height 0.25 which-key-idle-delay 0.8 which-key-max-description-length 25 which-key-allow-imprecise-window-fit t which-key-separator \u0026#34; â†’ \u0026#34; )) Now, whenever we hit a key that has a possible key-sequence, we\u0026#39;ll kind a nice menu reminding us of the keybinds we have setup. In this configuration, if I hit SPC-b, I\u0026#39;ll get the following prompt:\nMinibuffer The default mini-buffer area (where you are prompted when using the M-x command for example) is pretty lacking by default. There are a few packages we can use to make things much better in this regard.\nVertico This replaces the default mini-buffer with a vertical and much more descriptive prompt, we can set it up using:\n(use-package vertico :general ;; you probably want this, lets backspace delete and entire directory completion, instead of ;; one char at a time. (:keymaps \u0026#39;vertico-map \u0026#34;\u0026lt;backspace\u0026gt;\u0026#34; #\u0026#39;vertico-directory-delete-char \u0026#34;DEL\u0026#34; #\u0026#39;vertico-directory-delete-char) :init (vertico-mode)) Here you can also see we use the :general use-package keyword. This allows us to setup general bindings for the package/keymap we specify.\nHeres what the mini-buffer prompt looked like before we installed this package: And heres what it looks like after: Marginalia Marginalia provides descriptive annoations to the mini-buffer, and overall makes searching for information a lot easier.\nWe can install it by using the definition:\n(use-package marginalia :init (marginalia-mode)) Now, our output is much more descriptive: Orderless Orderless makes is a completion style that divides searches into space seperated characters or words, and doesn\u0026#39;t need to be sequential. It ammends this style to both the mini-buffer as well as corfu which we will setup after this.\nFor example, if I did ran M+x and input \u0026#34;key desc\u0026#34;, without orderless, I would get the following output: After installing orderless, it can match based on my search terms seen here: Installing orderless is simple enough, just use the following:\n(use-package orderless :config (setq completion-styles \u0026#39;(orderless basic) completion-category-overrides \u0026#39;((file (styles basic partial-completion))))) Completions Corfu + Cape Emacs has a few different completion framworks you can use, but the best I\u0026#39;ve found is Corfu. Corfu can be integrated with many completion methods like an LSP, and/or other packages such as Cape which provides completion functions for things like elisp code, keywords, and words present in the buffer. We can set these up with the following:\n(use-package corfu :config (setq corfu-popupinfo-delay 0 corfu-auto t corfu-cycle t corfu-preselect \u0026#39;prompt corfu-auto-delay 0.2 corfu-auto-prefix 2) (advice-add \u0026#39;eglot-completion-at-point :around #\u0026#39;cape-wrap-buster) :init (corfu-popupinfo-mode) (global-corfu-mode) (corfu-history-mode)) (use-package cape :init (add-to-list \u0026#39;completion-at-point-functions #\u0026#39;cape-dabbrev) (add-to-list \u0026#39;completion-at-point-functions #\u0026#39;cape-file) (add-to-list \u0026#39;completion-at-point-functions #\u0026#39;cape-elisp-block) (add-to-list \u0026#39;completion-at-point-functions #\u0026#39;cape-keyword)) Now we\u0026#39;ll be prompted for completions when entering in emacs function or variable names, and will provide the documentation for them. This makes things a bit easier to write/undertand when starting out. Heres what those completions may look like: Look and Feel Theme Emacs by default is in light mode, which disturbs me to the core of my soul. We can replace it with a dark theme. In this example, we will use Catpuccin, but you can find some others here. To install, we can add the following:\n(use-package catppuccin-theme :config (setq catppuccin-highlight-matches t) (load-theme \u0026#39;catppuccin t)) Now our eyes wont be fried anytime we open emacs: Dashboard Every good editor needs a sick dashboard. The main option used in emacs is dashboard.el. Lets add it in:\n(use-package dashboard :config (dashboard-setup-startup-hook)) Now we\u0026#39;re cooking: Diredfl This package changed the highlighting used in dired buffers. As stated in the preface, dired is one of the best file browsers I\u0026#39;ve ever used in general, so you\u0026#39;ll probably spending a lot of time looking at it. We can install using:\n(use-package diredfl :config (diredfl-global-mode)) Heres a before and after: Preferences Here are some other useful tweaks/peferences you can add in if you\u0026#39;re inclinded to do so:\n;; set font size to 12 point (set-face-attribute \u0026#39;default nil :height 120) ;; disable menus (menu-bar-mode -1) ;; disable toolbar (tool-bar-mode -1) ;; disable scrollbar (scroll-bar-mode -1) ;; automatically close pairs like (), [] and {} (electric-pair-mode 1) ;; highlight the current line (global-hl-line-mode) ;; automatically indent (electric-indent-mode t) ;; display line numbers (global-display-line-numbers-mode 1) ;; truncate lines, nowrap (setq-default truncate-lines t) ;; stop emacs from inserting impertive configs into init.el ;; by dumping them into a custom.el file that will never be loaded (setq custom-file (concat user-emacs-directory \u0026#34;/custom.el\u0026#34;) make-backup-files nil ; stop creating backup ~ files auto-save-default nil ; stop creating autosave # files create-lockfiles nil ; stop creating lock .# files blink-cursor-mode nil ; exactly what is sounds like use-short-answers t ; lets you type y,n instead of yes,no when prompted use-dialog-box nil ; disable gui menu pop-ups display-line-numbers-type \u0026#39;relative ; enable relative line numbers password-cache-expiry nil) ; prevents tramp passwords from expiring ;; Automatically refresh dired buffer when a change on disk is made (add-hook \u0026#39;dired-mode-hook \u0026#39;auto-revert-mode) Final Product Summary The gist of this setup was getting Vim bindings setup, and some quality of life improvements to fix the default look and functionality of Emacs. From here, you can check into some other packages you\u0026#39;re interested in. Typically on a package\u0026#39;s documention, they have setup steps included for setting up, along with using with use-package.\nThe corresponding init.el we\u0026#39;ve written in this guide an be found here. Here are some other awesome packages I recommend you check out and look into configuring. % - means the package is built into emacs by default\neglot % - LSP Client for Emacs org mode % - Tool for writing notes and documents in emacs tramp % - Tool for connecting and editing remote files magit - One of the best git clients ever created, build directly into emacs yasnippet - Provide snippets for completion for use with corfu sideline - Provide LSP diagnostic info directly in the buffer perspective - Different workspaces with different sets of buffers visible to it org-modern - Enhances the look and rendering of org documents org-roam - A note-takers best friend consult - Can be used as a fuzzy finder affe - Fuzzy Finder like consult, faster but more experimental undo-tree - Better handling of undo/redo actions in emacs rainbow-delimters - Uses color to distinguish matching pairs like {} and () rainbow-mode - Render hex and RGB values directly in the buffer ","date":"2024-04-28T00:00:00Z","image":"https://justinlime.dev/p/nvim-to-emacs/stallman_hu529d46d278dfdd21d5cb5e8373c39fd7_11405_120x120_fill_q75_box_smart1.jpg","permalink":"https://justinlime.dev/p/nvim-to-emacs/","title":"Switching from Neovim to Emacs"},{"content":" Emacs Emacs is configured exclusively through code, 99% of which is elisp code. See section 2 under elisp for why this is important. By default, Emacs uses keychords. Due to the prevalence of modifier keys, these have a special notation, using shortened aliases, for example C-c g. Refer to the Emacs tutorial for an explanation. This notation can be transformed into an elisp object via the kbd macro. All but the last key pressed are prefixes, \u0026#34;branches\u0026#34; in the keybindings where you have several other keys to choose from after pressing them. The most important prefix is C-c, as this, by convention, contains all user-defined keybindings. For a list of common/mandatory keybindings (including navigation, buffer and window management, and others), refer to the Emacs tutorial. Emacs offers various GUI interfaces for configuration (installing packages, setting options, etc), however these insert code into your init file, and are not opaque state.\nGeneral tips for beginners Try to stick to built-in functionality wherever possible at the beginning. Try to avoid the use of DSLs/complex macros (i.e. use-package). Emacs has a built-in package manager, I recommend enabling the MELPA community repo. Elisp Elisp is based on s-expressions, the syntax for which is (function-name arg1 arg2 ...). This syntax is based on lists, to be covered in 2.3. As the name suggests, everything is an expression, and thus every s-expression returns a value. Variables are evaluated via their name. That means that foo is both valid elisp and will evaluate the variable foo and return its value. The language makes no distinction between functions, macros and operators, everything is called in the s-expression form. Elisp (and lisps in general) use kebab-case names. Naming conventions include stars (\u0026#34;earmuffs\u0026#34;) around the name of global variables and plus signs around the names of constants. There are no \u0026#34;decorators\u0026#34; for function names and local variable names. Additionally, there are two special variables, t (analoguous to true) and nil, which is analogous to both false and NULL in other languages.\nFunctions Functions are defined with the defun macro (or lambda for anonymous functions) and have certain special properties. Firstly, they have 3 types of arguments: required, optional and rest arguments. The first 2 are self-explanatory, the 3rd collects all extra arguments passed into one list (similiar to variadic arguments). Secondly, they have docstrings. Since functions work on lists (their body is a rest argument), their definitions are composed of forms. Forms are either s-expressions or Lisp objects. If the first form is a string and there are other forms, it becomes a docstring and will be available through the help facility (again, refer to the Emacs tutorial for the usage of said help facility). The last form of a function body will be automatically returned (of course, early returns are possible), hence the necessity for further forms. The third special property of functions is the interactive specifier. It defines that the function is a command (callable through execute-extended-command and via keybindings) and defines how it\u0026#39;s arguments are supplied by the user.\nData types and symbols Elisp is strongly typed, if you pass a wrong type to a function, you\u0026#39;ll receive an error. However, it is also dynamically typed, meaning that values themselves have types (such as numbers and strings), not variables. Generally, types are what you\u0026#39;d expect from any other language, with two exceptions: the Lisp-specific data types, symbol and cons.\nSymbols and quoting Symbols are similiar to identifiers\tin other languages. The chief difference is that unlike in other languages, you can operate on symbols. This done through the quoting mechanism. Ordinarily, when you call an identifier, it will evaluate to it\u0026#39;s value. However, with the \u0026#39; operator, it will instead evaluate to the symbol itself (effectively removing the quote). Symbols are unique objects, differentiated by name, so are often preferred to strings for options, both for ease of use and for peformance reasons. Quoting is the mechanism macros use to expand to code.\nCons The cons is the most basic data type in Lisp, and is what makes up a list, the primary data type of Lisp. Conses are important for list manipulation, and have special syntax (through reader macros, the same way \u0026#39; works). There are two ways of creating a cons, either the cons function or the dot syntax: (first . second). Here, we will create a cons of two elements, from the values of the first and second variables. This will create a list with 3 elements, including the closing nil. The function list can be used to create lists of an arbitrary number of elements, however lists under the hood are \u0026#34;cons cells\u0026#34;. For example, the list (1 2 3) is actually:\n(1 . (2 . (3 . nil))) The first element can be accessed with the car function and the rest of the list with the cdr function. These can be chained, therefore, if you want the 3rd element of the aforementioned list, you\u0026#39;d write:\n(car (cdr (cdr (list 1 2 3)))) (yes, there are prettier ways of doing this). Additionally, you may sometimes see \u0026#34;list literals\u0026#34;, in the form of \u0026#39;(1 2 3). These are the same as the version created by the list function but are not modifiable.\nREPL and interactivity Emacs is an image-based program and is therefore (almost) completely interactive and introspectable. Emacs consists of a small C core and millions of lines of Elisp, either as extensions or as libraries. Every variable and line of code that is written in Elisp is modifiable at runtime (if you know what you\u0026#39;re doing), meaning there\u0026#39;s no need to ever restart Emacs, but it might sometimes be easier. Additionally, the help system automatically links to the definition of the current symbol being examined. You can use this to view the definitons and default values of functions and variables, but they\u0026#39;re not meant for editing, that should be done through the init file. Your interface to the Emacs image is the REPL. There are two ways of accessing it: either the eval-expression command or the scratch buffer, which is a more fully featured (but entirely text-based) REPL. emacs-lisp-mode defines several keybinds for loading code into the REPL. Note that if code is not loaded into the REPL, it does not exist, as far as Emacs is concerned. Emacs will automatically load the init.el file at startup.\nDependencies and loading When you load an elisp file into the REPL, all code in it will be loaded. Loading can be done in two ways: either through the primitive load function that simply takes a pathname string and loads the specified file or through the feature system. Features are symbols that represent an elisp file. They\u0026#39;re defined through provide (usually put at the end of a file) and loaded through require, which will search the list of currently defined features and if it finds the requested one, loads the appropriate file. Both are Elisp code and therefore will be executed upon loading, dealing with transitive dependencies. If you want to use a certain feature of Emacs, you need to load the appropriate file first. Say you want to configure the LSP client, Emacs, you need to first (require \u0026#39;eglot) before setting variables.\n","date":"2024-04-26T00:00:00Z","image":"https://justinlime.dev/p/emacs-crash-course/stallman_huf63ab074f8bc0286d608269ec9aaca25_952069_120x120_fill_q75_box_smart1.jpg","permalink":"https://justinlime.dev/p/emacs-crash-course/","title":"Emacs and Elisp Crash Course"},{"content":" Overview Direnv is a really nice tool for automatically loading ENV variables into your shell when entering a directory containing a .envrc file. First things first, lets install Nix.\nNix Nix is a cross-platform package manager, based on a purely functional langauge of the same name, with very up-to-date packages and is the largest package repository available. Nix can be used on any linux distribution, and even MacOS and WSL. All packages installed with Nix are completely indendant of each-other, and will only share dependencies of other packages if their computed hash is the same (basically, if they\u0026#39;re expecting the exact same version). This means that \u0026#34;Dependency Hell\u0026#34; does not really exist using Nix. You can have multiple versions of the same package installed at the same time with Nix, like libraries and other dependencies.\nAfter installing nix to your system, we need to allow the experimental features: flake and nix-command. To do this, we need to add a line to our nix.conf file. This is typically found in $XDG_CONFIG_HOME, which is usally $HOME/.config. So, assuming this, you can run the following commad to enable these features:\nmkdir -p $HOME/.config/nix \u0026amp;\u0026amp; echo \u0026#34;extra-experimental-features = flakes nix-command\u0026#34; \u0026gt; $HOME/.config/nix/nix.conf Setting up you Dev Shell With both Direv and Nix (with flakes enabled) installed, we can setup out Dev enviroment. Firstly, our project must live in a Git repo. So lets create one.\ncd /your/project/directory git init git branch -m main # If these aren\u0026#39;t already set globally by you git config user.email your_email_here git config user.name your_name_here touch flake.nix Now lets add some contents to our flake. With your favorite text editor, open your flake.nix and drop in the following contents:\n{ inputs = { nixpkgs.url = \u0026#34;github:nixos/nixpkgs/nixos-unstable\u0026#34;; }; outputs = { self, nixpkgs }: let forAllSystems = function: nixpkgs.lib.genAttrs [ \u0026#34;x86_64-linux\u0026#34; \u0026#34;x86_64-darwin\u0026#34; \u0026#34;aarch64-linux\u0026#34; ] (system: function (import nixpkgs { inherit system; })); in { devShells = forAllSystems (pkgs: { default = pkgs.mkShell { packages = with pkgs; [ gcc # Packages to be added for you dev shell here ]; shellHook = \u0026#39;\u0026#39; clear echo \u0026#34;DevShell Activated\u0026#34; \u0026#39;\u0026#39;; }; }); }; } If you\u0026#39;ve never used nix, this may look confusing, but the gist of what this is doing, is defining a default dev shell with the listed packages (in this case just gcc) installed to the shell\u0026#39;s environment. The shellHook is a shell script that gets run when entering our shell.\nNow that we have our flake, save the changes and add it to the git repo:\ngit add flake.nix We can test it out now by running nix develop in the project directory.\nSetting up Direnv Now that we have our development shell created and ready to use, we can have direnv automatically activate this shell environment when we enter the directory. To do this, we\u0026#39;ll add a .envrc file with the line use flakes to the root of our repository/directory. Afterwards, we need to allow/give permission for this directory to activate with direnv. For this, we use the command: direnv allow\nHeres a one-liner for this:\necho \u0026#34;use flake\u0026#34; \u0026gt; .envrc \u0026amp;\u0026amp; direnv allow Heres a One Shot Ive created a template for the flake mentioned above, this template can be used to bootstrap and cover the boilerplate needed for a basic flake.\nSo long as you have nix installed, flakes enabled, and a git repo, heres a nice copy-paste to do everything I\u0026#39;ve mentioned above. git init \u0026amp;\u0026amp; \\ nix flake init --template github:justinlime/devflakes#generic \u0026amp;\u0026amp; \\ nix flake lock \u0026amp;\u0026amp; \\ echo \u0026#34;use flake\u0026#34; \u0026gt; .envrc \u0026amp;\u0026amp; \\ echo \u0026#34;.direnv/\u0026#34; \u0026gt;\u0026gt; .gitignore \u0026amp;\u0026amp; \\ git add flake.nix flake.lock .gitignore .envrc \u0026amp;\u0026amp; \\ direnv allow The snippet above does the following:\nCreates a Git Repo in the directory if one doesn\u0026#39;t exist Creates a flake.nix based on my template Creates a flake.lock for said flake, which locks the packages for maximum reproducibility Creates a .envrc for direnv integration Appends .gitignore to ignore the auto-generated .direnv directory Adds all the created files to be staged for commit Activates direnv for the directory Happy Deving!\n","date":"2023-12-06T00:00:00Z","image":"https://justinlime.dev/p/nix/nix_hu8401412b500aa3e1a123550dda49eaae_42187_120x120_fill_box_smart1_3.png","permalink":"https://justinlime.dev/p/nix/","title":"Direnv and Nix"}]